{"title":"Análise dos dados do experimento de eficiência de inseticidas no controle de lagartas da traça-do-tomateiro","markdown":{"yaml":{"title":"Análise dos dados do experimento de eficiência de inseticidas no controle de lagartas da traça-do-tomateiro","format":"html","editor":"visual","editor_options":{"chunk_output_type":"console"},"warning":false,"message":false},"headingText":"Objetivos e hipóteses","containsRefs":false,"markdown":"\n\n\nPor meio da análise dos dados, objetivou-se determinar a eficiência de inseticidas no controle de lagartas de *Phthorimaea absoluta*.\n\n## Hipóteses testadas\n\n-   **Hipótese nula (H~0~):** Não há diferença significativa entre os tratamentos. A média da eficiência dos tratamentos no controle é igual para todos os inseticidas.\n\n-   **Hipótese alternativa (H~a~):** Pelo menos um dos inseticidas apresenta um desempenho significativamente melhor do que o controle, em comparação com os demais.\n\n# Análise das variáveis resposta\n\n## Pré-análise dos dados\n\n**Pacotes**: os seguintes pacotes R foram utilizados para as análises.\n\n```{r}\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(forcats)\nlibrary(stringr)\nlibrary(plotly)\nlibrary(readr)\nlibrary(emmeans)\nlibrary(multcomp)\nlibrary(multcompView)\nlibrary(DHARMa)\nlibrary(car)\nlibrary(glmmTMB)\nlibrary(lme4)\nlibrary(performance)\nlibrary(MASS)\nlibrary(dunn.test)\n```\n\n**Carregamento dos dados:** como o dataframe contendo os dados de eficiência dos inseticidas estava localizado em uma planilha Excel no desktop, para o carregamento dos dados, foi necessário utilizar a função `read_excel` do pacote `readxl`. O dataframe foi atribuído ao objeto denominado `dados`.\n\n```{r}\ndados <- read_excel(\"teste_lagarta_traça.xlsx\")\n\ndados\n```\n\n## Análise visual dos dados\n\nUsando o pacote `ggplot2`, foi explorado visualmente, por meio de diferentes gráficos, os dados de eficiência dos inseticidas.\n\n**Gráfico de barras:** primeiramente, foi visualizada a proporção de mortalidade de insetos em cada tratamento. A proporção de insetos mortos foi calculada pela fórmula:\n\n$PM = TM / (TV + TM)$\n\nPM = proporção de mortos\n\nTM = total de insetos mortos no tratamento\n\nTV = total de insetos vivos no tratamento\n\n```{r}\nproporcao_mortos <- dados |>\n  group_by(tratamento) |>\n  summarise(\n    TM = sum(mortos, na.rm = TRUE),\n    TV = sum(vivos, na.rm = TRUE)\n  ) |>\n  mutate(\n    tratamento = str_to_title(tratamento),\n    PM = TM / (TM + TV)\n  ) |>\n  ungroup() |>\n  arrange(PM) |>\n  mutate(tratamento = factor(tratamento, levels = tratamento)) \n     \nprint(proporcao_mortos)\n\ngrafico_proporcao <- ggplot(proporcao_mortos, aes(x = tratamento, y = PM)) +\n  geom_col(fill = \"darkgreen\") +\n  labs(\n    title = \"Proporção de insetos mortos por tratamento\",\n    x = \"Tratamentos\",\n    y = \"Proporção de mortos\"\n  ) +\n  ylim(0, 1) +\n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(size = 18, face = \"bold\", hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),  \n    panel.grid.minor.x = element_blank())\n\ngrafico_interativo <- plotly::ggplotly(grafico_proporcao) |>\n  plotly::config(displayModeBar = FALSE)\n\ngrafico_interativo\n```\n\n**Adição de facetas:** a visualização de cada tratamento individualmente foi possibilitada pela adição de facetas, permitindo analisar o comportamento de cada repetição (número de insetos mortos). Isso foi feito com a função `facet_wrap`.\n\n```{r}\ndados |>\n  ggplot(aes(repetição, mortos))+\n  geom_col(fill = \"darkgreen\")+\n  labs(x = \"Repetições\",\n       y = \"Número de insetos mortos\")+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank())+\n  scale_y_continuous(limits = c(0, 10), n.breaks = 3)+\n  facet_wrap(~ tratamento, labeller = labeller(tratamento = tools::toTitleCase))\n```\n\n## Mortalidade\n\nA mortalidade é descrita como:\n\n$MT = M / T$\n\nMT = mortalidade\n\nM = mortos\n\nT = total\n\n```{r}\ndados <- dados |>\n  mutate(\n    mortalidade = mortos / total)\n\nmedia_mortalidade <- dados |>\n  group_by(tratamento) |>\n  summarise(\n    mortalidade_media = mean(mortalidade, na.rm = TRUE),\n    .groups = \"drop\")\n\nmortalidade_controle <- media_mortalidade |>\n  filter(grepl(\"controle\", tolower(tratamento))) |>\n  pull(mortalidade_media)\n\nprint(mortalidade_controle)\nprint(media_mortalidade)\n```\n\n# Análises estatísticas\n\n## Análise das pressuposições da ANOVA\n\nPara que a ANOVA seja realizada é necessário que ela se enquandre nos seguintes pressupostos:\n\n-   Normalidade dos resíduos\n\n-   Homogeneidade de variâncias (homocedasticidade)\n\n-   Aditividade do modelo\n\n```{r}\nmodelo_anova <- aov(mortalidade ~ tratamento, data = dados)\n\nsummary(modelo_anova)\n```\n\n**Histograma dos resíduos**: foi criado o histograma dos resíduos da ANOVA, criado com a função `hist` a partir do objeto `modelo_anova`, serve para visualizar a distribuição desses resíduos. Isso permite verificar se eles são aproximadamente normais, uma suposição fundamental para a validade dos resultados da ANOVA.\n\n```{r}\nhist(residuals(modelo_anova))\n```\n\n```{r}\nplot(simulateResiduals(modelo_anova))\n```\n\n**Normalidade dos resíduos:** foi verificada pelo Shapiro teste, executado a partir da função `shapiro.test` a partir do objeto `modelo_anova`.\n\n```{r}\nshapiro.test(residuals(modelo_anova))\n```\n\nComo p-valor \\< 0.05, os resíduos não possuem normalidade.\n\n**Homogeneidade das variâncias:** foi testada pelo teste de Levene, por meio da função `leveneTest` aplicada a mortalidade por tratamento.\n\n```{r}\ncar::leveneTest(mortalidade ~ tratamento, data = dados)\n```\n\nComo o p-valor \\< 0.05, as variâncias são heterogêneas.\n\nAssim, observamos que os dados não atendem as pressuposições da ANOVA. Assim, se torna necessária a transformação dos dados ou a utilização de outros testes e modelos para a análise de dados. Com isso, apresentamos as duas formas de análise dos dados.\n\n## Transformação dos dados\n\nOs dados foram transformados pela função `anscombe = asin(sqrt(x))` (transformação angular (ou de Anscombe)). É uma transformação usada para dados de proporção\n\n```{r}\ndados <- dados %>%\n  mutate(\n    anscombe = asin(sqrt((mortos + 3/8) / (total + 3/4)))\n  )\n\nprint(dados)\n```\n\n**Aplicando a ANOVA novamente**\n\n```{r}\nmodelo_anova2 <- aov(anscombe ~ tratamento, data = dados)\n```\n\n**Histograma dos resíduos**\n\n```{r}\nhist(residuals(modelo_anova2))\n```\n\n**Normalidade dos resíduos**\n\n```{r}\nshapiro.test(residuals(modelo_anova2))\n```\n\nComo o p-valor \\< 0.05, os resíduos não são normais.\n\n**Homogeneidade das variâncias**\n\n```{r}\ncar::leveneTest(anscombe ~ tratamento, data = dados)\n```\n\nComo o p-valor \\< 0.05, as variâncias são heterogêneas.\n\nAssim, observamos que a transformação dos dados não foi suficiente para que eles atendessem as pressuposições da ANOVA.\n\n## **Teste de Kruskal-Wallis**\n\nO teste de Kruskal-Wallis é um teste não-paramétrico que verifica se há diferenças significativas entre os tratamentos analisados. Assim, ele foi aplicado aos dados de mortalidade.\n\n```{r}\nkruskal.test(mortalidade ~ tratamento, data = dados)\n```\n\nComo p-valor \\< 0.05, há diferenças significativas na mortalidade entre os tratamentos.\n\n### Comparações múltiplas\n\nPara realizar as comparações dos tratamentos foi realizado o teste de Dunn.\n\n```{r}\nteste_dunn <- dunn.test(dados$mortalidade, dados$tratamento, method = \"holm\")\n```\n\n```{r}\ncomparacoes <- teste_dunn$comparisons\npvals <- teste_dunn$P.adjusted\ngrupos <- unique(as.character(dados$tratamento))\nmatriz_p <- matrix(1, nrow = length(grupos), ncol = length(grupos),\n                   dimnames = list(grupos, grupos))\n\nfor (i in seq_along(comparacoes)) {\n  par <- unlist(strsplit(comparacoes[i], \" - \"))\n  matriz_p[par[1], par[2]] <- pvals[i]\n  matriz_p[par[2], par[1]] <- pvals[i]\n}\n\nletras <- multcompLetters(matriz_p)$Letters\nletras_df <- data.frame(tratamento = names(letras), letra = letras)\n\nsummary_ic <- dados %>%\n  group_by(tratamento) %>%\n  summarise(\n    media = mean(mortalidade, na.rm = TRUE),\n    n = n(),\n    sd = sd(mortalidade, na.rm = TRUE),\n    se = sd / sqrt(n),\n    ic = qt(0.975, df = n - 1) * se\n  )\n\nplot_df <- summary_ic %>%\n  left_join(letras_df, by = \"tratamento\") %>%\n  mutate(tratamento = str_to_title(tratamento))  \n\nggplot(plot_df, aes(x = tratamento, y = media)) +\n  geom_errorbar(aes(ymin = media - ic, ymax = media + ic), width = 0.2) +\n  geom_point(size = 3) +\n  geom_text(aes(label = letra, y = media + ic + 0.03), size = 5) +\n  labs(\n    title = \"Mortalidade por tratamento (Teste de Dunn)\",\n    x = \"Tratamento\",\n    y = \"Mortalidade\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n```\n\n## Modelos alternativos\n\nUma forma de analisar os dados sem transformação é a utilização de modelos que não exigem características semelhantes a da ANOVA. Dentre eles pode ser utilizado o GLM e GLMM.\n\n### Ajuste dos dados\n\nComo possuimos dados com valores de 0 ou 100% (ou seja, tudo morto ou tudo vivo), o modelo encontra problemas. Assim, os dados foram ajustado adicionando `0.5` ao número de mortos e vivos. A função `cbind` foi utilizada, pois estamos tratando de contagem de eventos (morto x vivo).\n\n```{r}\ndados$tratamento <- as.factor(dados$tratamento)\n\ndados_ajustados <- dados |>\n  dplyr::filter(mortos + vivos > 0) |>  \n  dplyr::mutate(\n    mortos_ajustados = mortos + 0.5,\n    vivos_ajustados = vivos + 0.5,\n    resposta_binomial = cbind(mortos_ajustados, vivos_ajustados))\n```\n\n### GLM - Modelo linear generalizado\n\nInicialmente, foi testado o modelo com **distribuição binomial**. Esse modelo é indicado quando os dados são proporcionais (insetos mortos / vivos). Com isso, é possível verificar se há diferença significativa entre os inseticidas testados quanto à mortalidade dos insetos. O argumento `family = binomial` foi utilizada por ter apenas dois resultados possíveis (sucesso ou fracasso). O link `logit` foi utilizado por se tratar de dados de proporção.\n\n```{r}\nmodelo_glm <- glm(resposta_binomial ~ tratamento,\n                                 family = binomial(link = \"logit\"),\n                                 data = dados_ajustados)\n\nsummary(modelo_glm)\n\nanova_glm <- anova(modelo_glm, data = dados_ajustados)\nprint(anova_glm)\n\nplot(simulateResiduals(modelo_glm))\nqqnorm(residuals(modelo_glm))\nqqline(residuals(modelo_glm))\n```\n\n```{r}\nres_dev_binomial <- sum(residuals(modelo_glm, type = \"deviance\")^2)\ndf_binomial <- df.residual(modelo_glm)\ndispersion_param_binomial <- res_dev_binomial / df_binomial\nprint(dispersion_param_binomial)\n```\n\nA análise do Modelo Linear Generalizado (GLM) com família binomial revelou um parâmetro de dispersão residual de **0.3272128**. Este valor, que é menor que 1, indicando a presença de **subdispersão** nos dados. Embora o teste de dispersão do DHARMa não tenha sido estatisticamente significativo (p = 0.184), a magnitude do parâmetro estimado (0.327) sugere que a variabilidade observada é consideravelmente menor do que a esperada sob a distribuição binomial padrão. Assim, a family foi ajustada para `quasibinomial`.\n\n**Distribuição quasibinomial**: o modelo GLM foi ajustado usando o argumento `family = quasibinomial`. Ele permite que o parâmetro de dispersão dos dados seja estimado, corrigindo os erros padrão e os testes de significância.\n\n```{r}\nmodelo_glm_qb <- glm(resposta_binomial ~ tratamento,\n                                 family = quasibinomial(link = \"logit\"),\n                                 data = dados_ajustados)\n\nsummary(modelo_glm_qb)\n\nm <- emmeans(modelo_glm_qb, ~ tratamento, type = \"response\")\nprint(m)\n\ncld_results <- cld(m, adjust = \"Tukey\", Letters = LETTERS)\nprint(cld_results)\n\ncld_df <- as.data.frame(cld_results) |> \n  dplyr::rename(group_sig = .group,\n                emmean = prob,\n                lower.CL = asymp.LCL,\n                upper.CL = asymp.UCL)\n\ncld_df <- cld_df |>\n  mutate(tratamento = str_to_sentence(tratamento))\n\n\nggplot(cld_df, aes(x = reorder(tratamento, emmean), y = emmean, fill = group_sig)) + \n  geom_bar(stat = \"identity\", fill = \"darkgreen\", color = \"black\") +\n  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.9)) +\n  geom_text(aes(y = upper.CL, label = group_sig),\n          vjust = -0.5, size = 4, color = \"black\")+\n  labs(title = \"Probabilidade estimada de resposta por tratamento (GLM Quasibinomial)\",\n       x = \"Tratamentos\",\n       y = \"Probabilidade estimada (EMM)\") +\n  theme_classic() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylim(0, max(cld_df$upper.CL) * 1)\n```\n\n```{r}\ndispersion_param_quasibinomial <- summary(modelo_glm_qb)$dispersion\nprint(dispersion_param_quasibinomial)\n```\n\nO valor **0.3183159** indica que os dados têm menos variabilidade (subdispersão) do que o observado pelo modelo binomial simples. O modelo `quasibinomial` utiliza esse valor para ajustar os p-valores e erros padrão, tornando a análise mais precisa.\n\n### GLMM - Modelo linear generalizado misto\n\nO GLMM é apropriado para os dados, porque a variável é binomial (mortos / vivos), tem um efeito fixo a ser testado (tratamentos) e possui efeitos aleatórios (repetições).\n\n```{r}\ndados$repetição <- as.factor(dados$repetição)\n\ndados$resposta_binomial <- cbind(dados$mortos, dados$vivos)\n\nmodelo_glmm <- glmer(resposta_binomial ~ tratamento + (1 | repetição),\n                     family = binomial(link = \"logit\"),\n                     data = dados_ajustados)\n\nsummary(modelo_glmm)\n\nemm <- emmeans(modelo_glmm, ~ tratamento, type = \"response\")\nletras <- cld(emm, adjust = \"tukey\", Letters = LETTERS)\n\nprint(letras)\n\nletras <- letras |>\n  mutate(tratamento = str_to_sentence(tratamento))\n\nggplot(as.data.frame(letras), aes(x = reorder (tratamento, prob), y = prob)) +\n  geom_col(fill = \"darkgreen\", color = \"black\") +\n  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), width = 0.2) +\n  geom_text(aes(y = asymp.UCL, label = .group),\n          vjust = -0.5, size = 4, color = \"black\") +\n  labs(title = \"Proporção de insetos mortos por tratamento (GLMM)\",\n         y = \"Proporção estimada de mortos\", x = \"Tratamentos\") +\n  theme_classic() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylim(0, max(cld_df$upper.CL) * 1.05)\n```\n\n```{r}\ndispersion_param_glmm <- sum(residuals(modelo_glmm, type = \"pearson\")^2) / df.residual(modelo_glmm)\nprint(dispersion_param_glmm)\n```\n\nO modelo apresentou um parâmetro de dispersão de **0.4918094**. Este valor, é inferior a 1, indicando claramente a presença de **subdispersão** nos dados, ou seja, a variabilidade observada é menor do que a esperada pela distribuição binomial padrão. Assim é necessário o ajuste do argumento.\n\n**Dispformula**: o modelo GLMM foi ajustado utilizando o argumento `dispformula = ~1`, que permite estimar um um valor de dispersão diferente do padrão. Assim, ele permite inferências mais precisas.\n\n```{r}\ndados_ajustados$mortos_ajustados <- ceiling(dados_ajustados$mortos_ajustados)\ndados_ajustados$vivos_ajustados <- ceiling(dados_ajustados$vivos_ajustados)\n\nmodelo_glmm_disp <- glmmTMB(cbind(mortos_ajustados, vivos_ajustados) ~ tratamento + (1 | repetição),\n                          family = binomial(link = \"logit\"),\n                          data = dados_ajustados, \n                          dispformula = ~1)\n\nsummary(modelo_glmm_disp)\n\noverdisp_check <- performance::check_overdispersion(modelo_glmm_disp)\nprint(overdisp_check)\n\nemm <- emmeans(modelo_glmm_disp, ~ tratamento, type = \"response\")\nprint(emm)\n\nletras <- cld(emm, adjust = \"tukey\", Letters = LETTERS)\nprint(letras)\n\nletras_df <- as.data.frame(letras) |>\ndplyr::rename(group_sig = .group,\nemmean = prob,\nlower.CL = asymp.LCL,\nupper.CL = asymp.UCL)\n\nletras_df <- letras_df |>\n  mutate(\n    grupo = case_when(\n      tratamento == \"Controle\" ~ \"Controle\",\n      emmean < 0.3 ~ \"Grupo Baixa Mortalidade\",\n      emmean >= 0.3 & emmean < 0.6 ~ \"Grupo Média Mortalidade\",\n      emmean >= 0.6 ~ \"Grupo Alta Mortalidade\",\n      TRUE ~ \"Outros\" \n    )\n  )\n\nletras_df <- letras_df |>\nmutate(tratamento = str_to_sentence(tratamento))\n\ngraf_glmm <- ggplot(letras_df, aes(x = reorder(tratamento, emmean), y = emmean, fill = grupo)) +\ngeom_bar(stat = \"identity\", color = \"black\") +\ngeom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.9)) +\ngeom_text(aes(y = upper.CL, label = group_sig),\nvjust = -0.5, size = 4, color = \"black\", fontface = \"bold\") +\nlabs(title = \"Proporção de insetos mortos por tratamento (GLMM Binomial com dispersão)\", \nx = \"Tratamentos\",\ny = \"Proporção estimada de mortos\",\nfill = \"Grupos de tratamento\") +\ntheme_classic() +\ntheme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\naxis.text.x = element_text(angle = 45, hjust = 1, size = 9)) +\nylim(0, max(letras_df$upper.CL) * 1.05) +\ncoord_flip() +\nscale_fill_manual(values = c(\n\"Controle\" = \"grey\",\n\"Grupo Baixa Mortalidade\" = \"#99d594\",\n\"Grupo Média Mortalidade\" = \"#67a9cf\",\n\"Grupo Alta Mortalidade\" = \"#af8dc3\",\n\"Outros\" = \"lightgrey\"\n))\n\nprint(graf_glmm)\n```\n\n```{r}\ndispersion_param_modelado <- sigma(modelo_glmm_disp)\nprint(paste(\"Parâmetro de dispersão (sigma) para Binomial com dispformula:\", dispersion_param_modelado))\n```\n\nNo modelo GLMM ajustado com `glmmTMB` e família binomial possui parâmetro de dispersão de **1**. Isso indica que, ao considerar os efeitos fixos e aleatórios, a variabilidade em seus dados está perfeitamente alinhada com o que a distribuição binomial prevê. Portanto, não há superdispersão nem subdispersão residual, e as inferências (p-valores e erros padrão) do seu modelo são consideradas válidas e precisas.\n\n### Comparação dos modelos\n\n#### Comparação do índice de dispersão\n\nFoi realizada a comparação do modelo GLM com distribuição quasibinomial e o modelo GLMM binomial com `dispformula`. O índice de dispersão do GLM foi de 0.318, indicando subdispersão, ou seja, variação abaixo da esperada, o que pode comprometer a validade estatística dos testes. Já o GLMM apresentou índice de dispersão de 0.863, próximo de 1, o que indica um ajuste mais adequado à variância dos dados. Portanto, o GLMM com dispersão é mais adequado por fornecer estimativas mais robustas e realistas para a inferência dos efeitos dos tratamentos.\n\n```{r}\ndisp_glm <- sum(residuals(modelo_glm_qb, type = \"pearson\")^2) / df.residual(modelo_glm_qb)\n\ndisp_glmm <- check_overdispersion(modelo_glmm_disp)\n\ncat(\"GLM quasibinomial - Índice de dispersão:\", round(disp_glm, 3), \"\\n\")\ncat(\"GLMM binomial - Índice de dispersão:\", round(disp_glmm$dispersion_ratio, 3), \"\\n\")\n```\n\n#### Modelo selecionado\n\n```{r}\nprint(graf_glmm)\n```\n\n## Curva de Probit\n\nA Curva de Probit foi feita para os inseticidas abamex, avatar, benevia, delegate e joiner. A Curva de Probit é um modelo de regressão onde a reposta binária (morto / vivo) é transformada pela função `probit` para ajustar uma relação linear com a dose transformada em log. Comum para cálculo da CL50.\n\n### Abamex\n\n```{r}\ndados_ab <- data.frame(\n  conc = c(25, 50, 5, 40, 10, 1),      \n  total = c(60, 60, 60, 60, 60, 60),                   \n  mortos = c(36, 56, 17, 41, 27, 8)     \n)\n\ndados_ab$mort_prop <- dados_ab$mortos / dados_ab$total \ndados_ab$lconc <- log10(dados_ab$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_ab)\n\nmodelo_reg_ab <- lm(mort_prop ~ lconc, data = dados_ab)\n\nprint(anova(modelo_reg_ab))\n\nprint(summary(modelo_reg_ab))\n\nmodelo_probit_ab <- glm(\n  cbind(mortos, total - mortos) ~ lconc,\n  data = dados_ab,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_ab))\n\npearson_chisq_ab <- sum(residuals(modelo_probit_ab, type = \"pearson\")^2)\ndf_chisq_ab <- nrow(dados_ab) - length(coef(modelo_probit_ab))\np_valor_chisq_ab <- pchisq(pearson_chisq_ab, df = df_chisq_ab, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_ab, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_ab, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_ab, 4), \"\\n\\n\"))\n\nprobabilidades_ab <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_ab <- dose.p(modelo_probit_ab, p = probabilidades_ab)\nerros_padrao_log_ab <- attr(cl_log_ab, \"SE\")\nz_valor_ab <- qnorm(0.975) \nlimite_inf_log_ab <- cl_log_ab - z_valor_ab * erros_padrao_log_ab\nlimite_sup_log_ab <- cl_log_ab + z_valor_ab * erros_padrao_log_ab\n\ntabela_escala_log10_ab <- data.frame(\n  Probabilidade = probabilidades_ab,\n  Log10_conc = cl_log_ab,\n  Limite_Inferior_95 = limite_inf_log_ab,\n  Limite_Superior_95 = limite_sup_log_ab\n)\n\ntabela_escala_conc_ab <- data.frame(\n  Probabilidade = probabilidades_ab,\n  Concentracao = 10^cl_log_ab,\n  Limite_Inferior_95 = 10^limite_inf_log_ab,\n  Limite_Superior_95 = 10^limite_sup_log_ab\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_ab)\n\nprint(tabela_escala_conc_ab)\n\nlconc_grafico_ab <- data.frame(lconc = seq(0, max(dados_ab$lconc) + 0.1, length.out = 200))\n\npredicoes_ab <- predict(modelo_probit_ab, newdata = lconc_grafico_ab, type = \"link\", se.fit = TRUE)\n\nz_valor_ab <- qnorm(0.975)\nlconc_grafico_ab$prob_predita_ab <- pnorm(predicoes_ab$fit)\nlconc_grafico_ab$prob_superior_ab <- pnorm(predicoes_ab$fit + z_valor_ab * predicoes_ab$se.fit)\nlconc_grafico_ab$prob_inferior_ab <- pnorm(predicoes_ab$fit - z_valor_ab * predicoes_ab$se.fit)\n\n\nlc50_log_ab <- as.numeric(dose.p(modelo_probit_ab, p = 0.50))\n\nlc50_conc_ab <- 10^lc50_log_ab\n\nx_lim_inferior_ab <- -1.5 \nx_lim_superior_ab <- 1    \n\nlconc_grafico_ab <- data.frame(lconc = seq(x_lim_inferior_ab, x_lim_superior_ab, length.out = 200))\n\npredicoes_ab <- predict(modelo_probit_ab, newdata = lconc_grafico_ab, type = \"link\", se.fit = TRUE)\nz_valor_ab <- qnorm(0.975)\nlconc_grafico_ab$prob_predita_ab <- pnorm(predicoes_ab$fit)\nlconc_grafico_ab$prob_superior_ab <- pnorm(predicoes_ab$fit + z_valor_ab * predicoes_ab$se.fit)\nlconc_grafico_ab$prob_inferior <- pnorm(predicoes_ab$fit - z_valor_ab * predicoes_ab$se.fit)\n\ngrafico_probit_final_ab <- ggplot() +\n  geom_ribbon(data = lconc_grafico_ab,\n              aes(x = lconc, ymin = prob_inferior * 100, ymax = prob_superior_ab * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_ab,\n            aes(x = lconc, y = prob_predita_ab * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_ab,\n             aes(x = lconc, y = mort_prop * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_ab, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Abamex\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_ab, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_ab, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_ab, x_lim_superior_ab), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_ab)\n```\n\n### Avatar\n\n```{r}\ndados_av <- data.frame(\n  conc = c(0.1, 1, 5, 10, 25, 40, 0.3, 0.5, 0.7),      \n  total = c(60, 60, 60, 60, 60, 60, 60, 60, 60),                   \n  mortos = c(0, 4, 16, 1, 15, 14, 3, 8, 6)     \n)\n\ndados_av$mort_prop_av <- dados_av$mortos / dados_av$total \ndados_av$lconc_av <- log10(dados_av$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_av)\n\nmodelo_reg_av <- lm(mort_prop_av ~ lconc_av, data = dados_av)\n\nprint(anova(modelo_reg_av))\n\nprint(summary(modelo_reg_av))\n\nmodelo_probit_av <- glm(\n  cbind(mortos, total - mortos) ~ lconc_av,\n  data = dados_av,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_av))\n\npearson_chisq_av <- sum(residuals(modelo_probit_av, type = \"pearson\")^2)\ndf_chisq_av <- nrow(dados_av) - length(coef(modelo_probit_av))\np_valor_chisq_av <- pchisq(pearson_chisq_av, df = df_chisq_av, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_av, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_av, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_av, 4), \"\\n\\n\"))\n\nprobabilidades_av <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_av <- dose.p(modelo_probit_av, p = probabilidades_av)\nerros_padrao_log_av <- attr(cl_log_av, \"SE\")\nz_valor_av <- qnorm(0.975) \nlimite_inf_log_av <- cl_log_av - z_valor_av * erros_padrao_log_av\nlimite_sup_log_av <- cl_log_av + z_valor_av * erros_padrao_log_av\n\ntabela_escala_log10_av <- data.frame(\n  Probabilidade = probabilidades_av,\n  Log10_conc = cl_log_av,\n  Limite_Inferior_95 = limite_inf_log_av,\n  Limite_Superior_95 = limite_sup_log_av\n)\n\ntabela_escala_conc_av <- data.frame(\n  Probabilidade = probabilidades_av,\n  Concentracao = 10^cl_log_av,\n  Limite_Inferior_95 = 10^limite_inf_log_av,\n  Limite_Superior_95 = 10^limite_sup_log_av\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_av)\n\nprint(tabela_escala_conc_av)\n\nlconc_grafico_av <- data.frame(lconc_av = seq(0, max(dados_av$lconc_av) + 0.1, length.out = 200))\n\npredicoes_av <- predict(modelo_probit_av, newdata = lconc_grafico_av, type = \"link\", se.fit = TRUE)\n\nz_valor_av <- qnorm(0.975)\nlconc_grafico_av$prob_predita_av <- pnorm(predicoes_av$fit)\nlconc_grafico_av$prob_superior_av <- pnorm(predicoes_av$fit + z_valor_av * predicoes_av$se.fit)\nlconc_grafico_av$prob_inferior_ab <- pnorm(predicoes_av$fit - z_valor_av * predicoes_av$se.fit)\n\nlc50_log_av <- as.numeric(dose.p(modelo_probit_av, p = 0.50))\n\nlc50_conc_av <- 10^lc50_log_av\n\nx_lim_inferior_av <- -1.5 \nx_lim_superior_av <- 1    \n\nlconc_grafico_av <- data.frame(lconc_av = seq(x_lim_inferior_av, x_lim_superior_av, length.out = 200))\n\npredicoes_av <- predict(modelo_probit_av, newdata = lconc_grafico_av, type = \"link\", se.fit = TRUE)\nz_valor_av <- qnorm(0.975)\nlconc_grafico_av$prob_predita_av <- pnorm(predicoes_av$fit)\nlconc_grafico_av$prob_superior_av <- pnorm(predicoes_av$fit + z_valor_av * predicoes_av$se.fit)\nlconc_grafico_av$prob_inferior_av <- pnorm(predicoes_av$fit - z_valor_av * predicoes_av$se.fit)\n\ngrafico_probit_final_av <- ggplot() +\n  geom_ribbon(data = lconc_grafico_av,\n              aes(x = lconc_av, ymin = prob_inferior_av * 100, ymax = prob_superior_av * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_av,\n            aes(x = lconc_av, y = prob_predita_av * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_av,\n             aes(x = lconc_av, y = mort_prop_av * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_av, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Avatar\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_av, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_av, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_av, x_lim_superior_av), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_av)\n```\n\n### Benevia\n\n```{r}\ndados_be <- data.frame(\n  conc = c(0.1, 1, 5, 10, 25, 40, 60),      \n  total = c(60, 60, 60, 60, 60, 50, 50),                   \n  mortos = c(1, 2, 8, 5, 44, 6, 8)     \n)\n\ndados_be$mort_prop_be <- dados_be$mortos / dados_be$total \ndados_be$lconc_be <- log10(dados_be$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_be)\n\nmodelo_reg_be <- lm(mort_prop_be ~ lconc_be, data = dados_be)\n\nprint(anova(modelo_reg_be))\n\nprint(summary(modelo_reg_be))\n\nmodelo_probit_be <- glm(\n  cbind(mortos, total - mortos) ~ lconc_be,\n  data = dados_be,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_be))\n\npearson_chisq_be <- sum(residuals(modelo_probit_be, type = \"pearson\")^2)\ndf_chisq_be <- nrow(dados_be) - length(coef(modelo_probit_be))\np_valor_chisq_be <- pchisq(pearson_chisq_be, df = df_chisq_be, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_be, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_be, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_be, 4), \"\\n\\n\"))\n\nprobabilidades_be <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_be <- dose.p(modelo_probit_be, p = probabilidades_be)\nerros_padrao_log_be <- attr(cl_log_be, \"SE\")\nz_valor_be <- qnorm(0.975) \nlimite_inf_log_be <- cl_log_be - z_valor_be * erros_padrao_log_be\nlimite_sup_log_be <- cl_log_be + z_valor_be * erros_padrao_log_be\n\ntabela_escala_log10_be <- data.frame(\n  Probabilidade = probabilidades_be,\n  Log10_conc = cl_log_be,\n  Limite_Inferior_95 = limite_inf_log_be,\n  Limite_Superior_95 = limite_sup_log_be\n)\n\ntabela_escala_conc_be <- data.frame(\n  Probabilidade = probabilidades_be,\n  Concentracao = 10^cl_log_be,\n  Limite_Inferior_95 = 10^limite_inf_log_be,\n  Limite_Superior_95 = 10^limite_sup_log_be\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_be)\n\nprint(tabela_escala_conc_be)\n\nlconc_grafico_be <- data.frame(lconc_be = seq(0, max(dados_be$lconc_be) + 0.1, length.out = 200))\n\npredicoes_be <- predict(modelo_probit_be, newdata = lconc_grafico_be, type = \"link\", se.fit = TRUE)\n\nz_valor_be <- qnorm(0.975)\nlconc_grafico_be$prob_predita_be <- pnorm(predicoes_be$fit)\nlconc_grafico_be$prob_superior_be <- pnorm(predicoes_be$fit + z_valor_be * predicoes_be$se.fit)\nlconc_grafico_be$prob_inferior_be <- pnorm(predicoes_be$fit - z_valor_be * predicoes_be$se.fit)\n\nlc50_log_be <- as.numeric(dose.p(modelo_probit_be, p = 0.50))\n\nlc50_conc_be <- 10^lc50_log_be\n\nx_lim_inferior_be <- -1.5 \nx_lim_superior_be <- 1    \n\nlconc_grafico_be <- data.frame(lconc_be = seq(x_lim_inferior_be, x_lim_superior_be, length.out = 200))\n\npredicoes_be <- predict(modelo_probit_be, newdata = lconc_grafico_be, type = \"link\", se.fit = TRUE)\nz_valor_be <- qnorm(0.975)\nlconc_grafico_be$prob_predita_be <- pnorm(predicoes_be$fit)\nlconc_grafico_be$prob_superior_be <- pnorm(predicoes_be$fit + z_valor_be * predicoes_be$se.fit)\nlconc_grafico_be$prob_inferior_be <- pnorm(predicoes_be$fit - z_valor_be * predicoes_be$se.fit)\n\ngrafico_probit_final_be <- ggplot() +\n  geom_ribbon(data = lconc_grafico_be,\n              aes(x = lconc_be, ymin = prob_inferior_be * 100, ymax = prob_superior_be * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_be,\n            aes(x = lconc_be, y = prob_predita_be * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_be,\n             aes(x = lconc_be, y = mort_prop_be * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_be, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Benevia\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_be, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_be, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_be, x_lim_superior_be), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_be)\n```\n\n### Delegate\n\n```{r}\ndados_de <- data.frame(\n  conc = c(0.1, 1),      \n  total = c(60, 60),                   \n  mortos = c(0,0)     \n)\n\ndados_de$mort_prop_de <- dados_de$mortos / dados_de$total \ndados_de$lconc_de <- log10(dados_de$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_de)\n\nmodelo_reg_de <- lm(mort_prop_de ~ lconc_de, data = dados_de)\n\nprint(anova(modelo_reg_de))\n\nprint(summary(modelo_reg_de))\n\nmodelo_probit_de <- glm(\n  cbind(mortos, total - mortos) ~ lconc_de,\n  data = dados_de,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_de))\n\npearson_chisq_de <- sum(residuals(modelo_probit_de, type = \"pearson\")^2)\ndf_chisq_de <- nrow(dados_de) - length(coef(modelo_probit_de))\np_valor_chisq_de <- pchisq(pearson_chisq_de, df = df_chisq_de, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_de, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_de, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_de, 4), \"\\n\\n\"))\n\nprobabilidades_de <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_de <- dose.p(modelo_probit_de, p = probabilidades_de)\nerros_padrao_log_de <- attr(cl_log_de, \"SE\")\nz_valor_de <- qnorm(0.975) \nlimite_inf_log_de <- cl_log_de - z_valor_de * erros_padrao_log_de\nlimite_sup_log_de <- cl_log_de + z_valor_de * erros_padrao_log_de\n\ntabela_escala_log10_de <- data.frame(\n  Probabilidade = probabilidades_de,\n  Log10_conc = cl_log_de,\n  Limite_Inferior_95 = limite_inf_log_de,\n  Limite_Superior_95 = limite_sup_log_de\n)\n\ntabela_escala_conc_de <- data.frame(\n  Probabilidade = probabilidades_de,\n  Concentracao = 10^cl_log_de,\n  Limite_Inferior_95 = 10^limite_inf_log_de,\n  Limite_Superior_95 = 10^limite_sup_log_de\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_de)\n\nprint(tabela_escala_conc_de)\n\nlconc_grafico_de <- data.frame(lconc_de = seq(0, max(dados_de$lconc_de) + 0.1, length.out = 200))\n\npredicoes_de <- predict(modelo_probit_de, newdata = lconc_grafico_de, type = \"link\", se.fit = TRUE)\n\nz_valor_de <- qnorm(0.975)\nlconc_grafico_de$prob_predita_de <- pnorm(predicoes_de$fit)\nlconc_grafico_de$prob_superior_de <- pnorm(predicoes_de$fit + z_valor_de * predicoes_de$se.fit)\nlconc_grafico_de$prob_inferior_de <- pnorm(predicoes_de$fit - z_valor_de * predicoes_de$se.fit)\n\nlc50_log_de <- as.numeric(dose.p(modelo_probit_de, p = 0.50))\n\nlc50_conc_de <- 10^lc50_log_de\n\nx_lim_inferior_de <- -1.5 \nx_lim_superior_de <- 1    \n\nlconc_grafico_de <- data.frame(lconc_de = seq(x_lim_inferior_de, x_lim_superior_de, length.out = 200))\n\npredicoes_de <- predict(modelo_probit_de, newdata = lconc_grafico_de, type = \"link\", se.fit = TRUE)\nz_valor_de <- qnorm(0.975)\nlconc_grafico_de$prob_predita_de <- pnorm(predicoes_de$fit)\nlconc_grafico_de$prob_superior_de <- pnorm(predicoes_de$fit + z_valor_de * predicoes_de$se.fit)\nlconc_grafico_de$prob_inferior_de <- pnorm(predicoes_de$fit - z_valor_de * predicoes_de$se.fit)\n\ngrafico_probit_final_de <- ggplot() +\n  geom_ribbon(data = lconc_grafico_de,\n              aes(x = lconc_de, ymin = prob_inferior_de * 100, ymax = prob_superior_de * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_de,\n            aes(x = lconc_de, y = prob_predita_de * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_de,\n             aes(x = lconc_de, y = mort_prop_de * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_de, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Delegate\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_de, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_de, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_de, x_lim_superior_de), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_de)\n```\n\n### Joiner\n\n```{r}\ndados_jo <- data.frame(\n  conc = c(0.00375, 0.0075, 0.01, 0.015, 0.03, 0.07, 0.1, 1, 3, 5, 10),      \n  total = c(60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60),                   \n  mortos = c(43, 6, 14, 2, 12, 15, 26, 36, 45, 49, 46)     \n)\n\ndados_jo$mort_prop_jo <- dados_jo$mortos / dados_jo$total \ndados_jo$lconc_jo <- log10(dados_jo$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_jo)\n\nmodelo_reg_jo <- lm(mort_prop_jo ~ lconc_jo, data = dados_jo)\n\nprint(anova(modelo_reg_jo))\n\nprint(summary(modelo_reg_jo))\n\nmodelo_probit_jo <- glm(\n  cbind(mortos, total - mortos) ~ lconc_jo,\n  data = dados_jo,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_jo))\n\npearson_chisq_jo <- sum(residuals(modelo_probit_jo, type = \"pearson\")^2)\ndf_chisq_jo <- nrow(dados_jo) - length(coef(modelo_probit_jo))\np_valor_chisq_jo <- pchisq(pearson_chisq_jo, df = df_chisq_jo, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_jo, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_jo, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_jo, 4), \"\\n\\n\"))\n\nprobabilidades_jo <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_jo <- dose.p(modelo_probit_jo, p = probabilidades_jo)\nerros_padrao_log_jo <- attr(cl_log_jo, \"SE\")\nz_valor_jo <- qnorm(0.975) \nlimite_inf_log_jo <- cl_log_jo - z_valor_jo * erros_padrao_log_jo\nlimite_sup_log_jo <- cl_log_jo + z_valor_jo * erros_padrao_log_jo\n\ntabela_escala_log10_jo <- data.frame(\n  Probabilidade = probabilidades_jo,\n  Log10_conc = cl_log_jo,\n  Limite_Inferior_95 = limite_inf_log_jo,\n  Limite_Superior_95 = limite_sup_log_jo\n)\n\ntabela_escala_conc_jo <- data.frame(\n  Probabilidade = probabilidades_jo,\n  Concentracao = 10^cl_log_jo,\n  Limite_Inferior_95 = 10^limite_inf_log_jo,\n  Limite_Superior_95 = 10^limite_sup_log_jo\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_jo)\n\nprint(tabela_escala_conc_jo)\n\nlconc_grafico_jo <- data.frame(lconc_jo = seq(0, max(dados_jo$lconc_jo) + 0.1, length.out = 200))\n\npredicoes_jo <- predict(modelo_probit_jo, newdata = lconc_grafico_jo, type = \"link\", se.fit = TRUE)\n\nz_valor_jo <- qnorm(0.975)\nlconc_grafico_jo$prob_predita_jo <- pnorm(predicoes_jo$fit)\nlconc_grafico_jo$prob_superior_jo <- pnorm(predicoes_jo$fit + z_valor_jo * predicoes_jo$se.fit)\nlconc_grafico_jo$prob_inferior_jo <- pnorm(predicoes_jo$fit - z_valor_jo * predicoes_jo$se.fit)\n\nlc50_log_jo <- as.numeric(dose.p(modelo_probit_jo, p = 0.50))\n\nlc50_conc_jo <- 10^lc50_log_jo\n\nx_lim_inferior_jo <- -1.5 \nx_lim_superior_jo <- 1    \n\nlconc_grafico_jo <- data.frame(lconc_jo = seq(x_lim_inferior_jo, x_lim_superior_jo, length.out = 200))\n\npredicoes_jo <- predict(modelo_probit_jo, newdata = lconc_grafico_jo, type = \"link\", se.fit = TRUE)\nz_valor_jo <- qnorm(0.975)\nlconc_grafico_jo$prob_predita_jo <- pnorm(predicoes_jo$fit)\nlconc_grafico_jo$prob_superior_jo <- pnorm(predicoes_jo$fit + z_valor_jo * predicoes_jo$se.fit)\nlconc_grafico_jo$prob_inferior_jo <- pnorm(predicoes_jo$fit - z_valor_jo * predicoes_jo$se.fit)\n\ngrafico_probit_final_jo <- ggplot() +\n  geom_ribbon(data = lconc_grafico_jo,\n              aes(x = lconc_jo, ymin = prob_inferior_jo * 100, ymax = prob_superior_jo * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_jo,\n            aes(x = lconc_jo, y = prob_predita_jo * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_jo,\n             aes(x = lconc_jo, y = mort_prop_jo * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_jo, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Joiner\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_jo, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_jo, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_jo, x_lim_superior_jo), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_jo)\n```\n\n**Interpretação da curva dose-resposta:** a CL50 corresponde no gráfico do ponto de interseção entre a linha horizontal de referência a 50% da mortalidade dos insetos, e a curva gerada pelo modelo. Foi possível estimar a CL50 apenas para o joiner (CL50 = 0.2598). Isso se deve ao fato de possuir poucos pontos para a estimação do parâmetro.\n\n# Conclusão\n\nConsiderando os agrupamentos dos tratamentos, de modo geral, a maioria dos inseticidas testados apresentam alta mortalidade contra as lagartas da traça do tomateiro. Diante dos resultados obtidos, observamos a necessidade de complementação dos dados.\n","srcMarkdownNoYaml":"\n\n# Objetivos e hipóteses\n\nPor meio da análise dos dados, objetivou-se determinar a eficiência de inseticidas no controle de lagartas de *Phthorimaea absoluta*.\n\n## Hipóteses testadas\n\n-   **Hipótese nula (H~0~):** Não há diferença significativa entre os tratamentos. A média da eficiência dos tratamentos no controle é igual para todos os inseticidas.\n\n-   **Hipótese alternativa (H~a~):** Pelo menos um dos inseticidas apresenta um desempenho significativamente melhor do que o controle, em comparação com os demais.\n\n# Análise das variáveis resposta\n\n## Pré-análise dos dados\n\n**Pacotes**: os seguintes pacotes R foram utilizados para as análises.\n\n```{r}\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(forcats)\nlibrary(stringr)\nlibrary(plotly)\nlibrary(readr)\nlibrary(emmeans)\nlibrary(multcomp)\nlibrary(multcompView)\nlibrary(DHARMa)\nlibrary(car)\nlibrary(glmmTMB)\nlibrary(lme4)\nlibrary(performance)\nlibrary(MASS)\nlibrary(dunn.test)\n```\n\n**Carregamento dos dados:** como o dataframe contendo os dados de eficiência dos inseticidas estava localizado em uma planilha Excel no desktop, para o carregamento dos dados, foi necessário utilizar a função `read_excel` do pacote `readxl`. O dataframe foi atribuído ao objeto denominado `dados`.\n\n```{r}\ndados <- read_excel(\"teste_lagarta_traça.xlsx\")\n\ndados\n```\n\n## Análise visual dos dados\n\nUsando o pacote `ggplot2`, foi explorado visualmente, por meio de diferentes gráficos, os dados de eficiência dos inseticidas.\n\n**Gráfico de barras:** primeiramente, foi visualizada a proporção de mortalidade de insetos em cada tratamento. A proporção de insetos mortos foi calculada pela fórmula:\n\n$PM = TM / (TV + TM)$\n\nPM = proporção de mortos\n\nTM = total de insetos mortos no tratamento\n\nTV = total de insetos vivos no tratamento\n\n```{r}\nproporcao_mortos <- dados |>\n  group_by(tratamento) |>\n  summarise(\n    TM = sum(mortos, na.rm = TRUE),\n    TV = sum(vivos, na.rm = TRUE)\n  ) |>\n  mutate(\n    tratamento = str_to_title(tratamento),\n    PM = TM / (TM + TV)\n  ) |>\n  ungroup() |>\n  arrange(PM) |>\n  mutate(tratamento = factor(tratamento, levels = tratamento)) \n     \nprint(proporcao_mortos)\n\ngrafico_proporcao <- ggplot(proporcao_mortos, aes(x = tratamento, y = PM)) +\n  geom_col(fill = \"darkgreen\") +\n  labs(\n    title = \"Proporção de insetos mortos por tratamento\",\n    x = \"Tratamentos\",\n    y = \"Proporção de mortos\"\n  ) +\n  ylim(0, 1) +\n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(size = 18, face = \"bold\", hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),  \n    panel.grid.minor.x = element_blank())\n\ngrafico_interativo <- plotly::ggplotly(grafico_proporcao) |>\n  plotly::config(displayModeBar = FALSE)\n\ngrafico_interativo\n```\n\n**Adição de facetas:** a visualização de cada tratamento individualmente foi possibilitada pela adição de facetas, permitindo analisar o comportamento de cada repetição (número de insetos mortos). Isso foi feito com a função `facet_wrap`.\n\n```{r}\ndados |>\n  ggplot(aes(repetição, mortos))+\n  geom_col(fill = \"darkgreen\")+\n  labs(x = \"Repetições\",\n       y = \"Número de insetos mortos\")+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank())+\n  scale_y_continuous(limits = c(0, 10), n.breaks = 3)+\n  facet_wrap(~ tratamento, labeller = labeller(tratamento = tools::toTitleCase))\n```\n\n## Mortalidade\n\nA mortalidade é descrita como:\n\n$MT = M / T$\n\nMT = mortalidade\n\nM = mortos\n\nT = total\n\n```{r}\ndados <- dados |>\n  mutate(\n    mortalidade = mortos / total)\n\nmedia_mortalidade <- dados |>\n  group_by(tratamento) |>\n  summarise(\n    mortalidade_media = mean(mortalidade, na.rm = TRUE),\n    .groups = \"drop\")\n\nmortalidade_controle <- media_mortalidade |>\n  filter(grepl(\"controle\", tolower(tratamento))) |>\n  pull(mortalidade_media)\n\nprint(mortalidade_controle)\nprint(media_mortalidade)\n```\n\n# Análises estatísticas\n\n## Análise das pressuposições da ANOVA\n\nPara que a ANOVA seja realizada é necessário que ela se enquandre nos seguintes pressupostos:\n\n-   Normalidade dos resíduos\n\n-   Homogeneidade de variâncias (homocedasticidade)\n\n-   Aditividade do modelo\n\n```{r}\nmodelo_anova <- aov(mortalidade ~ tratamento, data = dados)\n\nsummary(modelo_anova)\n```\n\n**Histograma dos resíduos**: foi criado o histograma dos resíduos da ANOVA, criado com a função `hist` a partir do objeto `modelo_anova`, serve para visualizar a distribuição desses resíduos. Isso permite verificar se eles são aproximadamente normais, uma suposição fundamental para a validade dos resultados da ANOVA.\n\n```{r}\nhist(residuals(modelo_anova))\n```\n\n```{r}\nplot(simulateResiduals(modelo_anova))\n```\n\n**Normalidade dos resíduos:** foi verificada pelo Shapiro teste, executado a partir da função `shapiro.test` a partir do objeto `modelo_anova`.\n\n```{r}\nshapiro.test(residuals(modelo_anova))\n```\n\nComo p-valor \\< 0.05, os resíduos não possuem normalidade.\n\n**Homogeneidade das variâncias:** foi testada pelo teste de Levene, por meio da função `leveneTest` aplicada a mortalidade por tratamento.\n\n```{r}\ncar::leveneTest(mortalidade ~ tratamento, data = dados)\n```\n\nComo o p-valor \\< 0.05, as variâncias são heterogêneas.\n\nAssim, observamos que os dados não atendem as pressuposições da ANOVA. Assim, se torna necessária a transformação dos dados ou a utilização de outros testes e modelos para a análise de dados. Com isso, apresentamos as duas formas de análise dos dados.\n\n## Transformação dos dados\n\nOs dados foram transformados pela função `anscombe = asin(sqrt(x))` (transformação angular (ou de Anscombe)). É uma transformação usada para dados de proporção\n\n```{r}\ndados <- dados %>%\n  mutate(\n    anscombe = asin(sqrt((mortos + 3/8) / (total + 3/4)))\n  )\n\nprint(dados)\n```\n\n**Aplicando a ANOVA novamente**\n\n```{r}\nmodelo_anova2 <- aov(anscombe ~ tratamento, data = dados)\n```\n\n**Histograma dos resíduos**\n\n```{r}\nhist(residuals(modelo_anova2))\n```\n\n**Normalidade dos resíduos**\n\n```{r}\nshapiro.test(residuals(modelo_anova2))\n```\n\nComo o p-valor \\< 0.05, os resíduos não são normais.\n\n**Homogeneidade das variâncias**\n\n```{r}\ncar::leveneTest(anscombe ~ tratamento, data = dados)\n```\n\nComo o p-valor \\< 0.05, as variâncias são heterogêneas.\n\nAssim, observamos que a transformação dos dados não foi suficiente para que eles atendessem as pressuposições da ANOVA.\n\n## **Teste de Kruskal-Wallis**\n\nO teste de Kruskal-Wallis é um teste não-paramétrico que verifica se há diferenças significativas entre os tratamentos analisados. Assim, ele foi aplicado aos dados de mortalidade.\n\n```{r}\nkruskal.test(mortalidade ~ tratamento, data = dados)\n```\n\nComo p-valor \\< 0.05, há diferenças significativas na mortalidade entre os tratamentos.\n\n### Comparações múltiplas\n\nPara realizar as comparações dos tratamentos foi realizado o teste de Dunn.\n\n```{r}\nteste_dunn <- dunn.test(dados$mortalidade, dados$tratamento, method = \"holm\")\n```\n\n```{r}\ncomparacoes <- teste_dunn$comparisons\npvals <- teste_dunn$P.adjusted\ngrupos <- unique(as.character(dados$tratamento))\nmatriz_p <- matrix(1, nrow = length(grupos), ncol = length(grupos),\n                   dimnames = list(grupos, grupos))\n\nfor (i in seq_along(comparacoes)) {\n  par <- unlist(strsplit(comparacoes[i], \" - \"))\n  matriz_p[par[1], par[2]] <- pvals[i]\n  matriz_p[par[2], par[1]] <- pvals[i]\n}\n\nletras <- multcompLetters(matriz_p)$Letters\nletras_df <- data.frame(tratamento = names(letras), letra = letras)\n\nsummary_ic <- dados %>%\n  group_by(tratamento) %>%\n  summarise(\n    media = mean(mortalidade, na.rm = TRUE),\n    n = n(),\n    sd = sd(mortalidade, na.rm = TRUE),\n    se = sd / sqrt(n),\n    ic = qt(0.975, df = n - 1) * se\n  )\n\nplot_df <- summary_ic %>%\n  left_join(letras_df, by = \"tratamento\") %>%\n  mutate(tratamento = str_to_title(tratamento))  \n\nggplot(plot_df, aes(x = tratamento, y = media)) +\n  geom_errorbar(aes(ymin = media - ic, ymax = media + ic), width = 0.2) +\n  geom_point(size = 3) +\n  geom_text(aes(label = letra, y = media + ic + 0.03), size = 5) +\n  labs(\n    title = \"Mortalidade por tratamento (Teste de Dunn)\",\n    x = \"Tratamento\",\n    y = \"Mortalidade\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n```\n\n## Modelos alternativos\n\nUma forma de analisar os dados sem transformação é a utilização de modelos que não exigem características semelhantes a da ANOVA. Dentre eles pode ser utilizado o GLM e GLMM.\n\n### Ajuste dos dados\n\nComo possuimos dados com valores de 0 ou 100% (ou seja, tudo morto ou tudo vivo), o modelo encontra problemas. Assim, os dados foram ajustado adicionando `0.5` ao número de mortos e vivos. A função `cbind` foi utilizada, pois estamos tratando de contagem de eventos (morto x vivo).\n\n```{r}\ndados$tratamento <- as.factor(dados$tratamento)\n\ndados_ajustados <- dados |>\n  dplyr::filter(mortos + vivos > 0) |>  \n  dplyr::mutate(\n    mortos_ajustados = mortos + 0.5,\n    vivos_ajustados = vivos + 0.5,\n    resposta_binomial = cbind(mortos_ajustados, vivos_ajustados))\n```\n\n### GLM - Modelo linear generalizado\n\nInicialmente, foi testado o modelo com **distribuição binomial**. Esse modelo é indicado quando os dados são proporcionais (insetos mortos / vivos). Com isso, é possível verificar se há diferença significativa entre os inseticidas testados quanto à mortalidade dos insetos. O argumento `family = binomial` foi utilizada por ter apenas dois resultados possíveis (sucesso ou fracasso). O link `logit` foi utilizado por se tratar de dados de proporção.\n\n```{r}\nmodelo_glm <- glm(resposta_binomial ~ tratamento,\n                                 family = binomial(link = \"logit\"),\n                                 data = dados_ajustados)\n\nsummary(modelo_glm)\n\nanova_glm <- anova(modelo_glm, data = dados_ajustados)\nprint(anova_glm)\n\nplot(simulateResiduals(modelo_glm))\nqqnorm(residuals(modelo_glm))\nqqline(residuals(modelo_glm))\n```\n\n```{r}\nres_dev_binomial <- sum(residuals(modelo_glm, type = \"deviance\")^2)\ndf_binomial <- df.residual(modelo_glm)\ndispersion_param_binomial <- res_dev_binomial / df_binomial\nprint(dispersion_param_binomial)\n```\n\nA análise do Modelo Linear Generalizado (GLM) com família binomial revelou um parâmetro de dispersão residual de **0.3272128**. Este valor, que é menor que 1, indicando a presença de **subdispersão** nos dados. Embora o teste de dispersão do DHARMa não tenha sido estatisticamente significativo (p = 0.184), a magnitude do parâmetro estimado (0.327) sugere que a variabilidade observada é consideravelmente menor do que a esperada sob a distribuição binomial padrão. Assim, a family foi ajustada para `quasibinomial`.\n\n**Distribuição quasibinomial**: o modelo GLM foi ajustado usando o argumento `family = quasibinomial`. Ele permite que o parâmetro de dispersão dos dados seja estimado, corrigindo os erros padrão e os testes de significância.\n\n```{r}\nmodelo_glm_qb <- glm(resposta_binomial ~ tratamento,\n                                 family = quasibinomial(link = \"logit\"),\n                                 data = dados_ajustados)\n\nsummary(modelo_glm_qb)\n\nm <- emmeans(modelo_glm_qb, ~ tratamento, type = \"response\")\nprint(m)\n\ncld_results <- cld(m, adjust = \"Tukey\", Letters = LETTERS)\nprint(cld_results)\n\ncld_df <- as.data.frame(cld_results) |> \n  dplyr::rename(group_sig = .group,\n                emmean = prob,\n                lower.CL = asymp.LCL,\n                upper.CL = asymp.UCL)\n\ncld_df <- cld_df |>\n  mutate(tratamento = str_to_sentence(tratamento))\n\n\nggplot(cld_df, aes(x = reorder(tratamento, emmean), y = emmean, fill = group_sig)) + \n  geom_bar(stat = \"identity\", fill = \"darkgreen\", color = \"black\") +\n  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.9)) +\n  geom_text(aes(y = upper.CL, label = group_sig),\n          vjust = -0.5, size = 4, color = \"black\")+\n  labs(title = \"Probabilidade estimada de resposta por tratamento (GLM Quasibinomial)\",\n       x = \"Tratamentos\",\n       y = \"Probabilidade estimada (EMM)\") +\n  theme_classic() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylim(0, max(cld_df$upper.CL) * 1)\n```\n\n```{r}\ndispersion_param_quasibinomial <- summary(modelo_glm_qb)$dispersion\nprint(dispersion_param_quasibinomial)\n```\n\nO valor **0.3183159** indica que os dados têm menos variabilidade (subdispersão) do que o observado pelo modelo binomial simples. O modelo `quasibinomial` utiliza esse valor para ajustar os p-valores e erros padrão, tornando a análise mais precisa.\n\n### GLMM - Modelo linear generalizado misto\n\nO GLMM é apropriado para os dados, porque a variável é binomial (mortos / vivos), tem um efeito fixo a ser testado (tratamentos) e possui efeitos aleatórios (repetições).\n\n```{r}\ndados$repetição <- as.factor(dados$repetição)\n\ndados$resposta_binomial <- cbind(dados$mortos, dados$vivos)\n\nmodelo_glmm <- glmer(resposta_binomial ~ tratamento + (1 | repetição),\n                     family = binomial(link = \"logit\"),\n                     data = dados_ajustados)\n\nsummary(modelo_glmm)\n\nemm <- emmeans(modelo_glmm, ~ tratamento, type = \"response\")\nletras <- cld(emm, adjust = \"tukey\", Letters = LETTERS)\n\nprint(letras)\n\nletras <- letras |>\n  mutate(tratamento = str_to_sentence(tratamento))\n\nggplot(as.data.frame(letras), aes(x = reorder (tratamento, prob), y = prob)) +\n  geom_col(fill = \"darkgreen\", color = \"black\") +\n  geom_errorbar(aes(ymin = asymp.LCL, ymax = asymp.UCL), width = 0.2) +\n  geom_text(aes(y = asymp.UCL, label = .group),\n          vjust = -0.5, size = 4, color = \"black\") +\n  labs(title = \"Proporção de insetos mortos por tratamento (GLMM)\",\n         y = \"Proporção estimada de mortos\", x = \"Tratamentos\") +\n  theme_classic() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ylim(0, max(cld_df$upper.CL) * 1.05)\n```\n\n```{r}\ndispersion_param_glmm <- sum(residuals(modelo_glmm, type = \"pearson\")^2) / df.residual(modelo_glmm)\nprint(dispersion_param_glmm)\n```\n\nO modelo apresentou um parâmetro de dispersão de **0.4918094**. Este valor, é inferior a 1, indicando claramente a presença de **subdispersão** nos dados, ou seja, a variabilidade observada é menor do que a esperada pela distribuição binomial padrão. Assim é necessário o ajuste do argumento.\n\n**Dispformula**: o modelo GLMM foi ajustado utilizando o argumento `dispformula = ~1`, que permite estimar um um valor de dispersão diferente do padrão. Assim, ele permite inferências mais precisas.\n\n```{r}\ndados_ajustados$mortos_ajustados <- ceiling(dados_ajustados$mortos_ajustados)\ndados_ajustados$vivos_ajustados <- ceiling(dados_ajustados$vivos_ajustados)\n\nmodelo_glmm_disp <- glmmTMB(cbind(mortos_ajustados, vivos_ajustados) ~ tratamento + (1 | repetição),\n                          family = binomial(link = \"logit\"),\n                          data = dados_ajustados, \n                          dispformula = ~1)\n\nsummary(modelo_glmm_disp)\n\noverdisp_check <- performance::check_overdispersion(modelo_glmm_disp)\nprint(overdisp_check)\n\nemm <- emmeans(modelo_glmm_disp, ~ tratamento, type = \"response\")\nprint(emm)\n\nletras <- cld(emm, adjust = \"tukey\", Letters = LETTERS)\nprint(letras)\n\nletras_df <- as.data.frame(letras) |>\ndplyr::rename(group_sig = .group,\nemmean = prob,\nlower.CL = asymp.LCL,\nupper.CL = asymp.UCL)\n\nletras_df <- letras_df |>\n  mutate(\n    grupo = case_when(\n      tratamento == \"Controle\" ~ \"Controle\",\n      emmean < 0.3 ~ \"Grupo Baixa Mortalidade\",\n      emmean >= 0.3 & emmean < 0.6 ~ \"Grupo Média Mortalidade\",\n      emmean >= 0.6 ~ \"Grupo Alta Mortalidade\",\n      TRUE ~ \"Outros\" \n    )\n  )\n\nletras_df <- letras_df |>\nmutate(tratamento = str_to_sentence(tratamento))\n\ngraf_glmm <- ggplot(letras_df, aes(x = reorder(tratamento, emmean), y = emmean, fill = grupo)) +\ngeom_bar(stat = \"identity\", color = \"black\") +\ngeom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.9)) +\ngeom_text(aes(y = upper.CL, label = group_sig),\nvjust = -0.5, size = 4, color = \"black\", fontface = \"bold\") +\nlabs(title = \"Proporção de insetos mortos por tratamento (GLMM Binomial com dispersão)\", \nx = \"Tratamentos\",\ny = \"Proporção estimada de mortos\",\nfill = \"Grupos de tratamento\") +\ntheme_classic() +\ntheme(plot.title = element_text(hjust = 0.5, face = \"bold\"),\naxis.text.x = element_text(angle = 45, hjust = 1, size = 9)) +\nylim(0, max(letras_df$upper.CL) * 1.05) +\ncoord_flip() +\nscale_fill_manual(values = c(\n\"Controle\" = \"grey\",\n\"Grupo Baixa Mortalidade\" = \"#99d594\",\n\"Grupo Média Mortalidade\" = \"#67a9cf\",\n\"Grupo Alta Mortalidade\" = \"#af8dc3\",\n\"Outros\" = \"lightgrey\"\n))\n\nprint(graf_glmm)\n```\n\n```{r}\ndispersion_param_modelado <- sigma(modelo_glmm_disp)\nprint(paste(\"Parâmetro de dispersão (sigma) para Binomial com dispformula:\", dispersion_param_modelado))\n```\n\nNo modelo GLMM ajustado com `glmmTMB` e família binomial possui parâmetro de dispersão de **1**. Isso indica que, ao considerar os efeitos fixos e aleatórios, a variabilidade em seus dados está perfeitamente alinhada com o que a distribuição binomial prevê. Portanto, não há superdispersão nem subdispersão residual, e as inferências (p-valores e erros padrão) do seu modelo são consideradas válidas e precisas.\n\n### Comparação dos modelos\n\n#### Comparação do índice de dispersão\n\nFoi realizada a comparação do modelo GLM com distribuição quasibinomial e o modelo GLMM binomial com `dispformula`. O índice de dispersão do GLM foi de 0.318, indicando subdispersão, ou seja, variação abaixo da esperada, o que pode comprometer a validade estatística dos testes. Já o GLMM apresentou índice de dispersão de 0.863, próximo de 1, o que indica um ajuste mais adequado à variância dos dados. Portanto, o GLMM com dispersão é mais adequado por fornecer estimativas mais robustas e realistas para a inferência dos efeitos dos tratamentos.\n\n```{r}\ndisp_glm <- sum(residuals(modelo_glm_qb, type = \"pearson\")^2) / df.residual(modelo_glm_qb)\n\ndisp_glmm <- check_overdispersion(modelo_glmm_disp)\n\ncat(\"GLM quasibinomial - Índice de dispersão:\", round(disp_glm, 3), \"\\n\")\ncat(\"GLMM binomial - Índice de dispersão:\", round(disp_glmm$dispersion_ratio, 3), \"\\n\")\n```\n\n#### Modelo selecionado\n\n```{r}\nprint(graf_glmm)\n```\n\n## Curva de Probit\n\nA Curva de Probit foi feita para os inseticidas abamex, avatar, benevia, delegate e joiner. A Curva de Probit é um modelo de regressão onde a reposta binária (morto / vivo) é transformada pela função `probit` para ajustar uma relação linear com a dose transformada em log. Comum para cálculo da CL50.\n\n### Abamex\n\n```{r}\ndados_ab <- data.frame(\n  conc = c(25, 50, 5, 40, 10, 1),      \n  total = c(60, 60, 60, 60, 60, 60),                   \n  mortos = c(36, 56, 17, 41, 27, 8)     \n)\n\ndados_ab$mort_prop <- dados_ab$mortos / dados_ab$total \ndados_ab$lconc <- log10(dados_ab$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_ab)\n\nmodelo_reg_ab <- lm(mort_prop ~ lconc, data = dados_ab)\n\nprint(anova(modelo_reg_ab))\n\nprint(summary(modelo_reg_ab))\n\nmodelo_probit_ab <- glm(\n  cbind(mortos, total - mortos) ~ lconc,\n  data = dados_ab,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_ab))\n\npearson_chisq_ab <- sum(residuals(modelo_probit_ab, type = \"pearson\")^2)\ndf_chisq_ab <- nrow(dados_ab) - length(coef(modelo_probit_ab))\np_valor_chisq_ab <- pchisq(pearson_chisq_ab, df = df_chisq_ab, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_ab, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_ab, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_ab, 4), \"\\n\\n\"))\n\nprobabilidades_ab <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_ab <- dose.p(modelo_probit_ab, p = probabilidades_ab)\nerros_padrao_log_ab <- attr(cl_log_ab, \"SE\")\nz_valor_ab <- qnorm(0.975) \nlimite_inf_log_ab <- cl_log_ab - z_valor_ab * erros_padrao_log_ab\nlimite_sup_log_ab <- cl_log_ab + z_valor_ab * erros_padrao_log_ab\n\ntabela_escala_log10_ab <- data.frame(\n  Probabilidade = probabilidades_ab,\n  Log10_conc = cl_log_ab,\n  Limite_Inferior_95 = limite_inf_log_ab,\n  Limite_Superior_95 = limite_sup_log_ab\n)\n\ntabela_escala_conc_ab <- data.frame(\n  Probabilidade = probabilidades_ab,\n  Concentracao = 10^cl_log_ab,\n  Limite_Inferior_95 = 10^limite_inf_log_ab,\n  Limite_Superior_95 = 10^limite_sup_log_ab\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_ab)\n\nprint(tabela_escala_conc_ab)\n\nlconc_grafico_ab <- data.frame(lconc = seq(0, max(dados_ab$lconc) + 0.1, length.out = 200))\n\npredicoes_ab <- predict(modelo_probit_ab, newdata = lconc_grafico_ab, type = \"link\", se.fit = TRUE)\n\nz_valor_ab <- qnorm(0.975)\nlconc_grafico_ab$prob_predita_ab <- pnorm(predicoes_ab$fit)\nlconc_grafico_ab$prob_superior_ab <- pnorm(predicoes_ab$fit + z_valor_ab * predicoes_ab$se.fit)\nlconc_grafico_ab$prob_inferior_ab <- pnorm(predicoes_ab$fit - z_valor_ab * predicoes_ab$se.fit)\n\n\nlc50_log_ab <- as.numeric(dose.p(modelo_probit_ab, p = 0.50))\n\nlc50_conc_ab <- 10^lc50_log_ab\n\nx_lim_inferior_ab <- -1.5 \nx_lim_superior_ab <- 1    \n\nlconc_grafico_ab <- data.frame(lconc = seq(x_lim_inferior_ab, x_lim_superior_ab, length.out = 200))\n\npredicoes_ab <- predict(modelo_probit_ab, newdata = lconc_grafico_ab, type = \"link\", se.fit = TRUE)\nz_valor_ab <- qnorm(0.975)\nlconc_grafico_ab$prob_predita_ab <- pnorm(predicoes_ab$fit)\nlconc_grafico_ab$prob_superior_ab <- pnorm(predicoes_ab$fit + z_valor_ab * predicoes_ab$se.fit)\nlconc_grafico_ab$prob_inferior <- pnorm(predicoes_ab$fit - z_valor_ab * predicoes_ab$se.fit)\n\ngrafico_probit_final_ab <- ggplot() +\n  geom_ribbon(data = lconc_grafico_ab,\n              aes(x = lconc, ymin = prob_inferior * 100, ymax = prob_superior_ab * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_ab,\n            aes(x = lconc, y = prob_predita_ab * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_ab,\n             aes(x = lconc, y = mort_prop * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_ab, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Abamex\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_ab, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_ab, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_ab, x_lim_superior_ab), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_ab)\n```\n\n### Avatar\n\n```{r}\ndados_av <- data.frame(\n  conc = c(0.1, 1, 5, 10, 25, 40, 0.3, 0.5, 0.7),      \n  total = c(60, 60, 60, 60, 60, 60, 60, 60, 60),                   \n  mortos = c(0, 4, 16, 1, 15, 14, 3, 8, 6)     \n)\n\ndados_av$mort_prop_av <- dados_av$mortos / dados_av$total \ndados_av$lconc_av <- log10(dados_av$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_av)\n\nmodelo_reg_av <- lm(mort_prop_av ~ lconc_av, data = dados_av)\n\nprint(anova(modelo_reg_av))\n\nprint(summary(modelo_reg_av))\n\nmodelo_probit_av <- glm(\n  cbind(mortos, total - mortos) ~ lconc_av,\n  data = dados_av,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_av))\n\npearson_chisq_av <- sum(residuals(modelo_probit_av, type = \"pearson\")^2)\ndf_chisq_av <- nrow(dados_av) - length(coef(modelo_probit_av))\np_valor_chisq_av <- pchisq(pearson_chisq_av, df = df_chisq_av, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_av, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_av, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_av, 4), \"\\n\\n\"))\n\nprobabilidades_av <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_av <- dose.p(modelo_probit_av, p = probabilidades_av)\nerros_padrao_log_av <- attr(cl_log_av, \"SE\")\nz_valor_av <- qnorm(0.975) \nlimite_inf_log_av <- cl_log_av - z_valor_av * erros_padrao_log_av\nlimite_sup_log_av <- cl_log_av + z_valor_av * erros_padrao_log_av\n\ntabela_escala_log10_av <- data.frame(\n  Probabilidade = probabilidades_av,\n  Log10_conc = cl_log_av,\n  Limite_Inferior_95 = limite_inf_log_av,\n  Limite_Superior_95 = limite_sup_log_av\n)\n\ntabela_escala_conc_av <- data.frame(\n  Probabilidade = probabilidades_av,\n  Concentracao = 10^cl_log_av,\n  Limite_Inferior_95 = 10^limite_inf_log_av,\n  Limite_Superior_95 = 10^limite_sup_log_av\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_av)\n\nprint(tabela_escala_conc_av)\n\nlconc_grafico_av <- data.frame(lconc_av = seq(0, max(dados_av$lconc_av) + 0.1, length.out = 200))\n\npredicoes_av <- predict(modelo_probit_av, newdata = lconc_grafico_av, type = \"link\", se.fit = TRUE)\n\nz_valor_av <- qnorm(0.975)\nlconc_grafico_av$prob_predita_av <- pnorm(predicoes_av$fit)\nlconc_grafico_av$prob_superior_av <- pnorm(predicoes_av$fit + z_valor_av * predicoes_av$se.fit)\nlconc_grafico_av$prob_inferior_ab <- pnorm(predicoes_av$fit - z_valor_av * predicoes_av$se.fit)\n\nlc50_log_av <- as.numeric(dose.p(modelo_probit_av, p = 0.50))\n\nlc50_conc_av <- 10^lc50_log_av\n\nx_lim_inferior_av <- -1.5 \nx_lim_superior_av <- 1    \n\nlconc_grafico_av <- data.frame(lconc_av = seq(x_lim_inferior_av, x_lim_superior_av, length.out = 200))\n\npredicoes_av <- predict(modelo_probit_av, newdata = lconc_grafico_av, type = \"link\", se.fit = TRUE)\nz_valor_av <- qnorm(0.975)\nlconc_grafico_av$prob_predita_av <- pnorm(predicoes_av$fit)\nlconc_grafico_av$prob_superior_av <- pnorm(predicoes_av$fit + z_valor_av * predicoes_av$se.fit)\nlconc_grafico_av$prob_inferior_av <- pnorm(predicoes_av$fit - z_valor_av * predicoes_av$se.fit)\n\ngrafico_probit_final_av <- ggplot() +\n  geom_ribbon(data = lconc_grafico_av,\n              aes(x = lconc_av, ymin = prob_inferior_av * 100, ymax = prob_superior_av * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_av,\n            aes(x = lconc_av, y = prob_predita_av * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_av,\n             aes(x = lconc_av, y = mort_prop_av * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_av, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Avatar\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_av, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_av, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_av, x_lim_superior_av), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_av)\n```\n\n### Benevia\n\n```{r}\ndados_be <- data.frame(\n  conc = c(0.1, 1, 5, 10, 25, 40, 60),      \n  total = c(60, 60, 60, 60, 60, 50, 50),                   \n  mortos = c(1, 2, 8, 5, 44, 6, 8)     \n)\n\ndados_be$mort_prop_be <- dados_be$mortos / dados_be$total \ndados_be$lconc_be <- log10(dados_be$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_be)\n\nmodelo_reg_be <- lm(mort_prop_be ~ lconc_be, data = dados_be)\n\nprint(anova(modelo_reg_be))\n\nprint(summary(modelo_reg_be))\n\nmodelo_probit_be <- glm(\n  cbind(mortos, total - mortos) ~ lconc_be,\n  data = dados_be,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_be))\n\npearson_chisq_be <- sum(residuals(modelo_probit_be, type = \"pearson\")^2)\ndf_chisq_be <- nrow(dados_be) - length(coef(modelo_probit_be))\np_valor_chisq_be <- pchisq(pearson_chisq_be, df = df_chisq_be, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_be, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_be, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_be, 4), \"\\n\\n\"))\n\nprobabilidades_be <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_be <- dose.p(modelo_probit_be, p = probabilidades_be)\nerros_padrao_log_be <- attr(cl_log_be, \"SE\")\nz_valor_be <- qnorm(0.975) \nlimite_inf_log_be <- cl_log_be - z_valor_be * erros_padrao_log_be\nlimite_sup_log_be <- cl_log_be + z_valor_be * erros_padrao_log_be\n\ntabela_escala_log10_be <- data.frame(\n  Probabilidade = probabilidades_be,\n  Log10_conc = cl_log_be,\n  Limite_Inferior_95 = limite_inf_log_be,\n  Limite_Superior_95 = limite_sup_log_be\n)\n\ntabela_escala_conc_be <- data.frame(\n  Probabilidade = probabilidades_be,\n  Concentracao = 10^cl_log_be,\n  Limite_Inferior_95 = 10^limite_inf_log_be,\n  Limite_Superior_95 = 10^limite_sup_log_be\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_be)\n\nprint(tabela_escala_conc_be)\n\nlconc_grafico_be <- data.frame(lconc_be = seq(0, max(dados_be$lconc_be) + 0.1, length.out = 200))\n\npredicoes_be <- predict(modelo_probit_be, newdata = lconc_grafico_be, type = \"link\", se.fit = TRUE)\n\nz_valor_be <- qnorm(0.975)\nlconc_grafico_be$prob_predita_be <- pnorm(predicoes_be$fit)\nlconc_grafico_be$prob_superior_be <- pnorm(predicoes_be$fit + z_valor_be * predicoes_be$se.fit)\nlconc_grafico_be$prob_inferior_be <- pnorm(predicoes_be$fit - z_valor_be * predicoes_be$se.fit)\n\nlc50_log_be <- as.numeric(dose.p(modelo_probit_be, p = 0.50))\n\nlc50_conc_be <- 10^lc50_log_be\n\nx_lim_inferior_be <- -1.5 \nx_lim_superior_be <- 1    \n\nlconc_grafico_be <- data.frame(lconc_be = seq(x_lim_inferior_be, x_lim_superior_be, length.out = 200))\n\npredicoes_be <- predict(modelo_probit_be, newdata = lconc_grafico_be, type = \"link\", se.fit = TRUE)\nz_valor_be <- qnorm(0.975)\nlconc_grafico_be$prob_predita_be <- pnorm(predicoes_be$fit)\nlconc_grafico_be$prob_superior_be <- pnorm(predicoes_be$fit + z_valor_be * predicoes_be$se.fit)\nlconc_grafico_be$prob_inferior_be <- pnorm(predicoes_be$fit - z_valor_be * predicoes_be$se.fit)\n\ngrafico_probit_final_be <- ggplot() +\n  geom_ribbon(data = lconc_grafico_be,\n              aes(x = lconc_be, ymin = prob_inferior_be * 100, ymax = prob_superior_be * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_be,\n            aes(x = lconc_be, y = prob_predita_be * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_be,\n             aes(x = lconc_be, y = mort_prop_be * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_be, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Benevia\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_be, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_be, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_be, x_lim_superior_be), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_be)\n```\n\n### Delegate\n\n```{r}\ndados_de <- data.frame(\n  conc = c(0.1, 1),      \n  total = c(60, 60),                   \n  mortos = c(0,0)     \n)\n\ndados_de$mort_prop_de <- dados_de$mortos / dados_de$total \ndados_de$lconc_de <- log10(dados_de$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_de)\n\nmodelo_reg_de <- lm(mort_prop_de ~ lconc_de, data = dados_de)\n\nprint(anova(modelo_reg_de))\n\nprint(summary(modelo_reg_de))\n\nmodelo_probit_de <- glm(\n  cbind(mortos, total - mortos) ~ lconc_de,\n  data = dados_de,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_de))\n\npearson_chisq_de <- sum(residuals(modelo_probit_de, type = \"pearson\")^2)\ndf_chisq_de <- nrow(dados_de) - length(coef(modelo_probit_de))\np_valor_chisq_de <- pchisq(pearson_chisq_de, df = df_chisq_de, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_de, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_de, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_de, 4), \"\\n\\n\"))\n\nprobabilidades_de <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_de <- dose.p(modelo_probit_de, p = probabilidades_de)\nerros_padrao_log_de <- attr(cl_log_de, \"SE\")\nz_valor_de <- qnorm(0.975) \nlimite_inf_log_de <- cl_log_de - z_valor_de * erros_padrao_log_de\nlimite_sup_log_de <- cl_log_de + z_valor_de * erros_padrao_log_de\n\ntabela_escala_log10_de <- data.frame(\n  Probabilidade = probabilidades_de,\n  Log10_conc = cl_log_de,\n  Limite_Inferior_95 = limite_inf_log_de,\n  Limite_Superior_95 = limite_sup_log_de\n)\n\ntabela_escala_conc_de <- data.frame(\n  Probabilidade = probabilidades_de,\n  Concentracao = 10^cl_log_de,\n  Limite_Inferior_95 = 10^limite_inf_log_de,\n  Limite_Superior_95 = 10^limite_sup_log_de\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_de)\n\nprint(tabela_escala_conc_de)\n\nlconc_grafico_de <- data.frame(lconc_de = seq(0, max(dados_de$lconc_de) + 0.1, length.out = 200))\n\npredicoes_de <- predict(modelo_probit_de, newdata = lconc_grafico_de, type = \"link\", se.fit = TRUE)\n\nz_valor_de <- qnorm(0.975)\nlconc_grafico_de$prob_predita_de <- pnorm(predicoes_de$fit)\nlconc_grafico_de$prob_superior_de <- pnorm(predicoes_de$fit + z_valor_de * predicoes_de$se.fit)\nlconc_grafico_de$prob_inferior_de <- pnorm(predicoes_de$fit - z_valor_de * predicoes_de$se.fit)\n\nlc50_log_de <- as.numeric(dose.p(modelo_probit_de, p = 0.50))\n\nlc50_conc_de <- 10^lc50_log_de\n\nx_lim_inferior_de <- -1.5 \nx_lim_superior_de <- 1    \n\nlconc_grafico_de <- data.frame(lconc_de = seq(x_lim_inferior_de, x_lim_superior_de, length.out = 200))\n\npredicoes_de <- predict(modelo_probit_de, newdata = lconc_grafico_de, type = \"link\", se.fit = TRUE)\nz_valor_de <- qnorm(0.975)\nlconc_grafico_de$prob_predita_de <- pnorm(predicoes_de$fit)\nlconc_grafico_de$prob_superior_de <- pnorm(predicoes_de$fit + z_valor_de * predicoes_de$se.fit)\nlconc_grafico_de$prob_inferior_de <- pnorm(predicoes_de$fit - z_valor_de * predicoes_de$se.fit)\n\ngrafico_probit_final_de <- ggplot() +\n  geom_ribbon(data = lconc_grafico_de,\n              aes(x = lconc_de, ymin = prob_inferior_de * 100, ymax = prob_superior_de * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_de,\n            aes(x = lconc_de, y = prob_predita_de * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_de,\n             aes(x = lconc_de, y = mort_prop_de * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_de, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Delegate\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_de, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_de, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_de, x_lim_superior_de), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_de)\n```\n\n### Joiner\n\n```{r}\ndados_jo <- data.frame(\n  conc = c(0.00375, 0.0075, 0.01, 0.015, 0.03, 0.07, 0.1, 1, 3, 5, 10),      \n  total = c(60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60),                   \n  mortos = c(43, 6, 14, 2, 12, 15, 26, 36, 45, 49, 46)     \n)\n\ndados_jo$mort_prop_jo <- dados_jo$mortos / dados_jo$total \ndados_jo$lconc_jo <- log10(dados_jo$conc)             \n\nprint(\"Dados Iniciais:\")\nprint(dados_jo)\n\nmodelo_reg_jo <- lm(mort_prop_jo ~ lconc_jo, data = dados_jo)\n\nprint(anova(modelo_reg_jo))\n\nprint(summary(modelo_reg_jo))\n\nmodelo_probit_jo <- glm(\n  cbind(mortos, total - mortos) ~ lconc_jo,\n  data = dados_jo,\n  family = binomial(link = \"probit\")\n)\n\nprint(summary(modelo_probit_jo))\n\npearson_chisq_jo <- sum(residuals(modelo_probit_jo, type = \"pearson\")^2)\ndf_chisq_jo <- nrow(dados_jo) - length(coef(modelo_probit_jo))\np_valor_chisq_jo <- pchisq(pearson_chisq_jo, df = df_chisq_jo, lower.tail = FALSE)\n\ncat(paste(\"Estatística Qui-quadrado de Pearson:\", round(pearson_chisq_jo, 4), \"\\n\"))\ncat(paste(\"Graus de Liberdade (DF):\", df_chisq_jo, \"\\n\"))\ncat(paste(\"Pr > ChiSq (p-valor):\", round(p_valor_chisq_jo, 4), \"\\n\\n\"))\n\nprobabilidades_jo <- c(\n  seq(from = 0.01, to = 0.10, by = 0.01),\n  seq(from = 0.15, to = 0.90, by = 0.05),\n  seq(from = 0.91, to = 0.99, by = 0.01)\n)\n\ncl_log_jo <- dose.p(modelo_probit_jo, p = probabilidades_jo)\nerros_padrao_log_jo <- attr(cl_log_jo, \"SE\")\nz_valor_jo <- qnorm(0.975) \nlimite_inf_log_jo <- cl_log_jo - z_valor_jo * erros_padrao_log_jo\nlimite_sup_log_jo <- cl_log_jo + z_valor_jo * erros_padrao_log_jo\n\ntabela_escala_log10_jo <- data.frame(\n  Probabilidade = probabilidades_jo,\n  Log10_conc = cl_log_jo,\n  Limite_Inferior_95 = limite_inf_log_jo,\n  Limite_Superior_95 = limite_sup_log_jo\n)\n\ntabela_escala_conc_jo <- data.frame(\n  Probabilidade = probabilidades_jo,\n  Concentracao = 10^cl_log_jo,\n  Limite_Inferior_95 = 10^limite_inf_log_jo,\n  Limite_Superior_95 = 10^limite_sup_log_jo\n)\n\noptions(digits = 6) \n\nprint(tabela_escala_log10_jo)\n\nprint(tabela_escala_conc_jo)\n\nlconc_grafico_jo <- data.frame(lconc_jo = seq(0, max(dados_jo$lconc_jo) + 0.1, length.out = 200))\n\npredicoes_jo <- predict(modelo_probit_jo, newdata = lconc_grafico_jo, type = \"link\", se.fit = TRUE)\n\nz_valor_jo <- qnorm(0.975)\nlconc_grafico_jo$prob_predita_jo <- pnorm(predicoes_jo$fit)\nlconc_grafico_jo$prob_superior_jo <- pnorm(predicoes_jo$fit + z_valor_jo * predicoes_jo$se.fit)\nlconc_grafico_jo$prob_inferior_jo <- pnorm(predicoes_jo$fit - z_valor_jo * predicoes_jo$se.fit)\n\nlc50_log_jo <- as.numeric(dose.p(modelo_probit_jo, p = 0.50))\n\nlc50_conc_jo <- 10^lc50_log_jo\n\nx_lim_inferior_jo <- -1.5 \nx_lim_superior_jo <- 1    \n\nlconc_grafico_jo <- data.frame(lconc_jo = seq(x_lim_inferior_jo, x_lim_superior_jo, length.out = 200))\n\npredicoes_jo <- predict(modelo_probit_jo, newdata = lconc_grafico_jo, type = \"link\", se.fit = TRUE)\nz_valor_jo <- qnorm(0.975)\nlconc_grafico_jo$prob_predita_jo <- pnorm(predicoes_jo$fit)\nlconc_grafico_jo$prob_superior_jo <- pnorm(predicoes_jo$fit + z_valor_jo * predicoes_jo$se.fit)\nlconc_grafico_jo$prob_inferior_jo <- pnorm(predicoes_jo$fit - z_valor_jo * predicoes_jo$se.fit)\n\ngrafico_probit_final_jo <- ggplot() +\n  geom_ribbon(data = lconc_grafico_jo,\n              aes(x = lconc_jo, ymin = prob_inferior_jo * 100, ymax = prob_superior_jo * 100),\n              fill = \"skyblue\", alpha = 0.5) +\n  geom_line(data = lconc_grafico_jo,\n            aes(x = lconc_jo, y = prob_predita_jo * 100),\n            color = \"blue\", size = 1) +\n  geom_point(data = dados_jo,\n             aes(x = lconc_jo, y = mort_prop_jo * 100),\n             color = \"red\", size = 4) +\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  geom_vline(xintercept = lc50_log_jo, linetype = \"dashed\", color = \"black\", size = 0.7) +\n  labs(\n    title = \"Curva dose-resposta (Modelo Probit) - Joiner\",\n    x = \"Log10 (Concentração)\",\n    y = \"Mortalidade observada e prevista (%)\"\n  ) +\n  annotate(\"text\", \n           x = lc50_log_jo, \n           y = 45, \n           label = paste(\"LC50 =\", format(lc50_conc_jo, digits = 4)), \n           hjust = -0.1,\n           vjust = 1,\n           fontface = \"bold\",\n           color = \"black\") +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10), expand = c(0, 0)) +\n  scale_x_continuous(limits = c(x_lim_inferior_jo, x_lim_superior_jo), breaks = seq(-4, 1, 0.5)) +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\nprint(grafico_probit_final_jo)\n```\n\n**Interpretação da curva dose-resposta:** a CL50 corresponde no gráfico do ponto de interseção entre a linha horizontal de referência a 50% da mortalidade dos insetos, e a curva gerada pelo modelo. Foi possível estimar a CL50 apenas para o joiner (CL50 = 0.2598). Isso se deve ao fato de possuir poucos pontos para a estimação do parâmetro.\n\n# Conclusão\n\nConsiderando os agrupamentos dos tratamentos, de modo geral, a maioria dos inseticidas testados apresentam alta mortalidade contra as lagartas da traça do tomateiro. Diante dos resultados obtidos, observamos a necessidade de complementação dos dados.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"analises.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":{"light":"flatly","dark":"darkly"},"smooth-scroll":true,"title":"Análise dos dados do experimento de eficiência de inseticidas no controle de lagartas da traça-do-tomateiro","editor_options":{"chunk_output_type":"console"},"message":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}